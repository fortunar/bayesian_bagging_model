#' match_forecast_model
#'
#' Builds match_forecast_model to forecast match outcomes by performing bagging
#' using two level modeling. The approach takes into account the uncertainty in the inputs
#' to avoid overconfidence of ML models. Since the inputs to a match outcome prediction
#' problem are often uncertain the approach can enhance the predictive performance of ML models.
#'
#'
#'
#' For detailed explanation see the introduction vignette by running:
#' \code{vignette("introduction", package = "matchForecast")}
#'
#' @export
#'
#' @param data \code{data.frame} or \code{data.table} in \strong{event-instance}
#'   format required by this package (also see details below). Columns have to
#'   include instance ID's in the format: \strong{ID_<number>} and attributes in
#'   the format \strong{<attr_name>_<number>}. <number> suffix connects
#'   instances to attributes. The suffixed number of corresponding instance and
#'   attributes should be the same. Column for the outcome (dependant variable)
#'   of the event needs to be denoted with \strong{y}. It can also include an
#'   attribute \strong{TIME}.
#'
#'   An example of the columns for basketball data:
#'   \tabular{ccccccccc}{
#'    TIME \tab y \tab ID_1 \tab ID_2 \tab P2M_1 \tab P3M_1 \tab P2M_2 \tab P3M_2 \tab.. \cr
#'   }
#'   In the basketball case ID_1 refers to ID of the home team and P2M_1, P3M_1 to the
#'   attributes of the home team. ID_2 refers to the ID of away team and P2M_2, P3M_2 to its
#'   attributes. y is the outcome of the match.
#'
#' @param input_model_specification Specifies the parametric assumptions of the
#'   attributes. We can model attributes of instances as independent with uivariate models or as
#'   dependent with multivariate models.
#'
#'  Currently four univariate Bayesian models are supported: \itemize{
#'   \item Poisson (Poisson-Gamma model), appropriate for count data,
#'   see \code{\link{input_model_poisson}}
#'   \item Bernoulli (Bernoulli-Beta model), appropriate for binary data,
#'   see \code{\link{input_model_bernoulli}}
#'   \item Normal (Normal model with sample variance), appropriate for numeric data when
#'   modeling only mean, see \code{\link{input_model_normal}}
#'   \item normal (Normal-Inverse Gamma model), appropriate for jointly modeling mean and variance,
#'   see \code{\link{input_model_normal_ig}}
#'   }
#'
#'   One multivariate Bayesian model is supported:
#'   Multivariate normal model with inverse Wishart prior for covariance matrix
#'   (see \code{\link{input_model_mvnormal_iw}}). It is appropriate for jointly modeling numeric
#'   attributes of instances. A custom model can also be used if a function is passed as
#'    \code{input_model_specification} parameter. See the source code of other input models
#'    for an example of how to write a custom model.
#'
#'   \strong{How to invoke the models described above?}
#'   For independent Bayesian models a string or a list should be passed in as
#'   \code{input_model_specification} parameter. If it is a string, all attributes have the
#'   same parametric assumption. If it is a list, the keys need to correspond to
#'   columns (attributes) and values to parametric assumptions. If a list of
#'   name value pairs is used, different attributes can have different
#'   parametric assumptions. The strings corresponding to supported parametric assumptions described
#'   above are 'poisson', 'bernoulli', 'normal', 'normal_ig'. Multivariate normal model with
#'   inverse Wishart prior is invoked by passing in
#'   \code{input_model_specification = list(dependent = T, type = "mvnormal_iw")}.
#'   See examples below and input models linked above for more details.
#'
#' @param num_models Number of distributions to obtain per attribute. Also matches the
#'   number of resulting bagged ML models, since each bagged model is obtained on
#'   one set of distributions.
#' @param transformation Specifies how attribute distributions are transformed
#'   into actual features being fed into ML algorithm. For each of the parametric assumptions
#'   mentioned above mean transformation is supported out of the box. It is invoked by
#'   passing \code{transformation = "means"} as parameter. A custom function can also be
#'   passed in. In this case it gets called for every instance with a list of distributions
#'   that were fitted to instance attributes by the package. See the source code of
#'   \code{\link{transform_data}} for more information.
#' @param weighting Optional parameter. A function that uses the \strong{TIME} attribute if
#'   present to weight the prior events by importance when obtaining attribute
#'   distributions.
#' @param get_model Function that takes as input a dataset generated by
#'   \code{transformation} function and returns a ML model built using this
#'   dataset. The ML model returned needs to support the standard predict()
#'   notation.
#' @param priors Optional parameter. Specifies conjugate priors for supported Bayesian models.
#' List of lists, one for each instance. Keys in the outer list correspond to instance id's.
#' The values in the outer list correspond to specifications of prior distributions of attributes.
#' The values in the inner lists depend on the parametric assumption used. See the
#' documentation of supported parametric models for details on how to specify priors.
#' @param report_time Boolean denoting whether to report the execution time. Default is \code{FALSE}.
#' @return Structure of class \code{match_forecast_model} containing
#'   properties:
#'   \itemize{
#'   \item models: list of length \code{num_models} with each entry being one of the bagged
#'   models
#'   \item data: data passed to input parameter (to be used to calculate distributions of
#'   attributes of test instances
#'   \item some other implicit parameters to avoid repetition
#'   }
#' @example R/examples/example_match_forecast_model.R
match_forecast_model <- function(data,
                                    input_model_specification,
                                    num_models,
                                    transformation = NULL,
                                    weighting = NULL,
                                    get_model,
                                    priors = NULL,
                                    report_time = F) {
  start_time <- Sys.time()

  transformation_function <- get_transformation(transformation)

  data_specification <- list(
    cols_ids = get_id_colnames(data),
    cols_static = get_static_colnames(data),
    cols_measurements = get_measurement_colnames(data)
  )

  cols_measurements_suffixed <- NULL
  for (i in 1:length(data_specification$cols_ids)) {
    cols_measurements_suffixed <- c(
      cols_measurements_suffixed,
      paste(data_specification$cols_measurements, "_", i, sep = "")
    )
  }

  data_specification[["cols_measurements_suffixed"]] <- cols_measurements_suffixed

  data_modeled <- model_inputs(
    data,
    data,
    input_model_specification,
    num_models,
    weighting = weighting,
    priors = priors,
    data_specification
  )

  models <- list()
  for (i in 1:num_models) {
    data_modeled_current <- extract_model_data(data_modeled, i)
    data_modeled_current <- transformation_function(data_modeled_current)
    data_modeled_current <- data.frame(matrix(unlist(data_modeled_current), nrow = length(data_modeled_current), byrow = T))
    data_modeled_current <- reformat_to_df(data_modeled_current, data_specification)
    models[[i]] <- get_model(data_modeled_current)
  }

  model <- structure(
    list(
      models = models,
      input_model_specification = input_model_specification,
      data = data,
      priors = priors,
      transformation_function = transformation_function,
      data_specification = data_specification
    ),
    class = "match_forecast_model"
  )

  if (report_time) {
    print(paste("Model building time:", Sys.time() - start_time))
  }
  return(model)
}

#' predict.match_forecast_model
#'
#' Predict function for the match_forecast_model. Predicts the outcome for test
#' events using each of the bagged models built with match_forecast_model.
#' Instances from the test set modeled in the same way as instances in the train
#' set. For each event in the test set \code{num_samples} distributions are fitted
#' to each instance's attributes. This distribution is then transformed using the same
#' transformation (e.g. "means") to obtain final feature vectors.
#'
#' @export
#'
#' @param mf_model An instance of match_forecast_model
#' @param data_new \code{data.frame} or \code{data.table} with event data
#'  containing involved instance ID's.
#'
#'  Example of columns for test set:
#'  \tabular{ccc}{\tab ID_1 \tab ID_2\cr }
#'  Note that the attributes of new events are unknown and are therefore estimated from
#'  data used for training. If you want to calculate attributes for instances in the test
#'  set from different data, set the \code{data} attribute of the match_forecast_model,
#'  after building it.
#' @param num_samples Specifies how many distributions are fitted to each
#'  attribute of an instance.
#' @param weighting Same as in \code{\link{match_forecast_model}}.
#' @param predict_fun Function that gets as an argument one of the bagged models and
#' transformed test data (e.g. using "means" transformation). It should use the ML model's
#' predict function to obtain the outcome of new events.
#' @param report_time Boolean denoting whether to report the execution time.
#' @return List of lists of predictions. The size of the outer list is \code{num_models * num_samples},
#' since each of the bagged models is predicting on each of the sampled test instances.
#' Each prediction (inner list) contains fields:
#'  \itemize{
#'  \item predictions: output of predict_fun for corresponding model and sampled test instance
#'  \item model: index of the bagged model
#'  \item num_of_sample: index of the sampled test instance
#'  }
#' @example R/examples/example_predict.R
predict.match_forecast_model <- function(
  mf_model,
  data_new,
  num_models,
  weighting = NULL,
  predict_fun,
  report_time = F) {
  start_time <- Sys.time()

  data_modeled <- model_inputs(
    data_new,
    mf_model$data,
    mf_model$input_model_specification,
    num_models,
    weighting,
    mf_model$priors,
    mf_model$data_specification
  )

  predictions <- NULL
  for (i in 1:num_models) {
    data_modeled_current <- extract_model_data(data_modeled, i)
    data_modeled_current <- mf_model$transformation_function(data_modeled_current)
    data_modeled_current <- data.frame(
      matrix(unlist(data_modeled_current), nrow = length(data_modeled_current), byrow = T)
    )
    data_modeled_current <- reformat_to_df(
      data_modeled_current,
      mf_model$data_specification
    )
    for (j in 1:length(mf_model$models)) {
      predictions <- c(
        predictions,
        list(
          list(
            num_of_sample = i,
            model = j,
            predictions = predict_fun(mf_model$models[[j]], data_modeled_current)
          )
        )
      )
    }
  }

  if (report_time) {
    print(paste("Model prediction time:", Sys.time() - start_time))
  }
  return(predictions)
}

#' get_transformation
#'
#' Returns a function representing the transformation (i.e. way of obtaining
#' feature vectors). Returns the function itself if a function
#' is passed in as parameter. If a string is passed, it has to be one of the
#' supported transformations (currently only "means").
get_transformation <- function(transformation) {
  if (typeof(transformation) == "closure") {
    return(
      transform_data(
        transformation
      )
    )
  }
  supported_transformations <- list(
    means = transformation_means
  )
  if (typeof(transformation) != "character" ||
    !transformation %in% names(supported_transformations)) {
    stop("The transformation needs to be a function or one of supported transformations.")
  }
  return(
    transform_data(
      supported_transformations[[transformation]]
    )
  )
}

#' model_inputs
#'
#' Samples distributions for each attribute of the instances. Modularized as
#' function to prevent unnecessary repetition, since the same procedure is used
#' in both \code{\link{match_forecast_model}} and
#' \code{\link{predict.match_forecast_model}}.
model_inputs <- function(
                         data_to_model,
                         data_all,
                         input_model_specification,
                         num_models,
                         weighting = NULL,
                         priors = NULL,
                         data_specification) {
  cols_ids <- data_specification$cols_ids
  cols_static <- data_specification$cols_static
  cols_measurements <- data_specification$cols_measurements

  # List for optimization: save samples in case of repetition (e.g. for train data)
  instance_fits <- list()

  instance_measurements <- list()
  for (i in 1:nrow(data_to_model)) {
    for (j in 1:length(cols_ids)) {
      instance_id <- data_to_model[i, ][[cols_ids[[j]]]]
      if (is.null(instance_measurements[[instance_id]])) {
        instance_measurements[[instance_id]] <- get_instance_measurements(
          instance_id,
          data_all,
          cols_ids,
          cols_measurements
        )
      }
    }
  }

  data_modeled <- NULL
  instance_data_modeled <- list()
  for (i in 1:nrow(data_to_model)) {
    data_modeled_row <- list()
    # Copy static columns
    for (column in cols_static) {
      data_modeled_row[[column]] <- data_to_model[i, ][[column]]
    }

    for (j in 1:length(cols_ids)) {
      # Copy id columns
      data_modeled_row[[cols_ids[[j]]]] <- data_to_model[i, ][[cols_ids[[j]]]]

      instance_id <- data_to_model[i, ][[cols_ids[[j]]]]
      if (!is.null(instance_data_modeled[[instance_id]])) {
        data_modeled_row[[paste("instance_models_", j, sep = "")]] <- instance_data_modeled[[instance_id]]
        next
      }

      if (is.null(weighting)) {
        instance_measurements_weighted <- instance_measurements[[instance_id]]
      } else if (typeof(weighting) == "closure") {
        instance_measurements_weighted <- weighting(instance_measurements[[instance_id]])
      } else if (weighting == "gaussian") {
        instance_measurements_weighted <- weighting_gaussian(instance_measurements[[instance_id]], 1)
      }
      instance_measurements_weighted$TIME <- NULL

      instance_data_modeled[[instance_id]] <- model_inputs_row(
        instance_measurements_weighted,
        input_model_specification,
        num_models,
        priors[[instance_id]]
      )
      data_modeled_row[[paste("instance_models_", j, sep = "")]] <- instance_data_modeled[[instance_id]]
    }
    data_modeled <- c(
      data_modeled,
      list(data_modeled_row)
    )
  }
  return(data_modeled)
}

#' model_inputs_row
#'
#' Model the attributes of an instance (row) according to the input specification.
model_inputs_row <- function(data, input_model_specification, num_models, prior = NULL) {
  # Models supported by default
  supported_models <- list(
    poisson = input_model_poisson,
    normal = input_model_normal,
    normal_ig = input_model_normal_ig,
    bernoulli = input_model_bernoulli,
    mvnormal_iw = input_model_mvnormal_iw
  )

  models <- list()
  # Support for custom models
  if (typeof(input_model_specification) == 'closure') {
    return(input_model_specification(data, num_models))
  }


  # Simple types of models (each column modeled independently)
  if (!is.list(input_model_specification) || is.null(input_model_specification$dependent) || !input_model_specification$dependent) {
    column_models <- list()
    for (colname in colnames(data)) {
      if (typeof(input_model_specification) == 'character') {
        if (is.null(supported_models[[input_model_specification]])) {
          stop(paste(input_model_specification, "model not supported.", "Supported models are:", toString(names(supported_models))))
        }
        column_models[[colname]] <- supported_models[[input_model_specification]](data[[colname]], num_models, prior[[colname]])
      } else {
        if (is.null(input_model_specification[[colname]])) {
          stop(paste("Model for attribute", colname, "not specified."))
        } else if (is.null(supported_models[[input_model_specification[[colname]]]]))  {
          stop(paste(input_model_specification[[colname]], "model not supported.", "Supported models are:", toString(names(supported_models))))
        }
        column_models[[colname]] <- supported_models[[input_model_specification[[colname]]]](data[[colname]], num_models, prior[[colname]])
      }
    }

    for (i in 1:num_models) {
      inst_model <- instance_model()
      for (colname in colnames(data)) {
        inst_model$models[[colname]] <- column_models[[colname]][[i]]
      }
      models[[i]] <- inst_model
    }
  }
  # Modeling attributes as interdependent
  # Currently only modelling all attributes with mvnormal is supported
  else {
    if (is.null(supported_models[[input_model_specification$type]])) {
      stop(paste(input_model_specification$type, "model not supported.", "Supported models are:", toString(names(supported_models))))
    }
    models <- supported_models[[input_model_specification$type]](data, num_models, prior)
  }
  return(models)
}

#' get_instance_measurements
#'
#' Retrieves measurements of all attributes of an instance. One row denotes one event.
get_instance_measurements <- function(instance_id, data_all, cols_ids, cols_measurements) {
  data_instance_measurements <- data.table(matrix(ncol = length(cols_measurements) + 1, nrow = nrow(data_all)))
  colnames(data_instance_measurements) <- c("TIME", cols_measurements)
  for (col in colnames(data_instance_measurements)) {
    data_instance_measurements[[col]] <- as.double(data_instance_measurements[[col]])
  }
  data_instance_measurements[["TIME"]] <- as.integer(data_instance_measurements[["TIME"]])

  for (i in 1:nrow(data_all)) {
    for (j in 1:length(cols_ids)) {
      if (instance_id == data_all[i, ][[cols_ids[[j]]]]) {
        set(data_instance_measurements, i, "TIME", data_all[i, ][["TIME"]])
        for (col_measurement in cols_measurements) {
          set(
            data_instance_measurements,
            i,
            col_measurement,
            data_all[i, ][[paste(col_measurement, "_", j, sep = "")]]
          )
        }
      }
    }
  }

  return(data_instance_measurements[complete.cases(data_instance_measurements), ])
}

#' extract_model_data
#'
#' Extracts all of the \code{num_of_model}-th distribution fits for all instances.
extract_model_data <- function(data_modeled, num_of_model) {
  model_data_extracted <- list()
  for (i in 1:length(data_modeled)) {
    model_data_extracted_row <- list()
    for (attribute in names(data_modeled[[i]])) {
      if (substr(attribute, 1, 16) != "instance_models_") {
        # Copy static attributes
        model_data_extracted_row[[attribute]] <- data_modeled[[i]][[attribute]]
      } else {
        # Get num_of_model-th instance model
        model_data_extracted_row[[
        paste("instance_model_", substr_right(attribute, 1), sep = "")
        ]] <- data_modeled[[i]][[attribute]][[num_of_model]]
      }
    }
    model_data_extracted[[i]] <- model_data_extracted_row
  }
  return(model_data_extracted)
}
